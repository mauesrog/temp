"""String formatting utilities.

Provides useful methods to format strings.

.. _src-common-file-format:
    https://github.com/hivebattery/gui/blob/master/driver/src/common/file/hive_record.py

"""


def reconstruct_neat_string(S, w):
    """Compute the optimal distribution for printing a paragraph using a solution array.

    Reconstructs a solution generated by `format_string`.


    Args:
        S (list of int): The solution array generated by the dynamic programming algorithm.
        w (list of str): The paragraph (list of words) to be printed neatly.

    Returns:
        str: The neatly formatted paragraph.

    """
    cut = S[len(S) - 1]
    end = len(w)
    words = ""

    while cut != 0:
        chunk = ""

        for i in range(cut + 1, end + 1):
            chunk += w[i - 1]

            if i < end:
                chunk += " "

        if end != len(w):
            chunk += "\n"

        words = chunk + words

        end = cut
        cut = S[cut]

    chunk = ""

    for x in range(cut + 1, end + 1):
        chunk += w[x-1]

        if x < end:
            chunk += " "

    if end != len(w):
        chunk += "\n"

    return chunk + words


def format_string(w, m):
    """Format paragraph neatly.

    Uses the dynamic programming approach to print neatly, that is, produces the paragraph such that the sum of the
    cubes of the number trailing spaces in each line is minimized.

    Args:
        w (list of str): The paragraph (list of words) to be printed neatly.
        m (int): The maximum number of characters per line.

    Returns:
        str: The paragraph with the neatest possible format.

    """
    N = [0.0]
    S = [0]
    total_sum = 0

    for i in range(1, len(w) + 1):
        N.append(float("inf"))
        S.append(-1)

    for j in range(1, len(w) + 1):
        total_sum += len(w[j - 1])
        s = total_sum

        for k in range(j):
            if k > 0:
                s -= len(w[k - 1])

            p = m - j + k + 1 - s

            if p >= 0:
                if j == len(w):
                    p = 0
                else:
                    p **= 3

                c = N[k] + p

                if N[j] > c:
                    N[j] = c
                    S[j] = k

    return reconstruct_neat_string(S, w)